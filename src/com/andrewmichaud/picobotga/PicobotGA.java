/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.andrewmichaud.picobotga;

import java.util.*;

/**
 *
 * @author Andrew
 */
public class PicobotGA {
    
    // a very competent Picobot program generated by the Python version of
    // this project.
    String BESTPROGRAM = //<editor-fold>
            "0 NExx -> W 2 \n" +
            "0 NxWx -> E 2 \n" +
            "0 Nxxx -> X 2 \n" +
            "0 xExS -> N 4 \n" +
            "0 xExx -> S 2 \n" +
            "0 xxWS -> X 2 \n" +
            "0 xxWx -> X 2 \n" +
            "0 xxxS -> N 0 \n" +
            "0 xxxx -> S 3 \n" +
            "1 NExx -> X 4 \n" +
            "1 NxWx -> S 4 \n" +
            "1 Nxxx -> W 4 \n" +
            "1 xExS -> W 3 \n" +
            "1 xExx -> W 0 \n" +
            "1 xxWS -> E 0 \n" +
            "1 xxWx -> X 0 \n" +
            "1 xxxS -> E 1 \n" +
            "1 xxxx -> N 0 \n" +
            "2 NExx -> S 3 \n" +
            "2 NxWx -> S 1 \n" +
            "2 Nxxx -> X 3 \n" +
            "2 xExS -> W 0 \n" +
            "2 xExx -> W 4 \n" +
            "2 xxWS -> X 3 \n" +
            "2 xxWx -> S 0 \n" +
            "2 xxxS -> X 0 \n" +
            "2 xxxx -> X 1 \n" +
            "3 NExx -> S 3 \n" +
            "3 NxWx -> S 2 \n" +
            "3 Nxxx -> S 0 \n" +
            "3 xExS -> N 2 \n" +
            "3 xExx -> N 1 \n" +
            "3 xxWS -> E 4 \n" +
            "3 xxWx -> S 3 \n" +
            "3 xxxS -> N 4 \n" +
            "3 xxxx -> S 0 \n" +
            "4 NExx -> W 0 \n" +
            "4 NxWx -> E 4 \n" +
            "4 Nxxx -> W 3 \n" +
            "4 xExS -> X 1 \n" +
            "4 xExx -> X 1 \n" +
            "4 xxWS -> X 2 \n" +
            "4 xxWx -> N 0 \n" +
            "4 xxxS -> X 1 \n" +
            "4 xxxx -> N 4 ";
    //</editor-fold>
    
    final public static String BESTFITNESS = "3 NxWx -> E 3 \n" +
            "3 xxWx -> E 3 \n" +
            "1 xxWS -> N 0 \n" +
            "4 xxxx -> W 4 \n" +
            "2 NExx -> X 0 \n" +
            "2 xxxx -> X 1 \n" +
            "0 xxxS -> X 3 \n" +
            "2 xExx -> W 4 \n" +
            "1 NxxS -> W 4 \n" +
            "4 xExx -> S 3 \n" +
            "3 xExS -> W 3 \n" +
            "4 Nxxx -> E 4 \n" +
            "3 NxxS -> W 2 \n" +
            "4 NExx -> W 3 \n" +
            "1 xExS -> N 3 \n" +
            "0 NExx -> W 3 \n" +
            "3 xEWx -> N 2 \n" +
            "3 xxWS -> X 0 \n" +
            "4 xxxS -> E 1 \n" +
            "0 xxxx -> S 0 \n" +
            "1 NxWx -> E 4 \n" +
            "0 Nxxx -> E 2 \n" +
            "0 xEWx -> N 4 \n" +
            "2 Nxxx -> X 0 \n" +
            "2 xxxS -> W 2 \n" +
            "1 xxWx -> N 3 \n" +
            "1 xExx -> W 3 \n" +
            "4 xxWx -> N 3 \n" +
            "2 xxWx -> S 1 \n" +
            "0 xxWS -> N 3 \n" +
            "2 xEWx -> N 1 \n" +
            "3 Nxxx -> E 0 \n" +
            "3 xxxx -> E 3 \n" +
            "3 NExx -> X 3 \n" +
            "1 xxxS -> X 4 \n" +
            "3 xExx -> W 4 \n" +
            "2 xExS -> N 1 \n" +
            "0 xExS -> W 2 \n" +
            "4 NxxS -> W 2 \n" +
            "4 xEWx -> X 2 \n" +
            "2 NxxS -> E 0 \n" +
            "4 NxWx -> X 0 \n" +
            "1 NExx -> W 0 \n" +
            "0 xxWx -> X 3 \n" +
            "0 NxxS -> W 3 \n" +
            "4 xxWS -> E 0 \n" +
            "3 xxxS -> E 0 \n" +
            "4 xExS -> N 3 \n" +
            "1 xEWx -> N 1 \n" +
            "1 xxxx -> N 1 \n" +
            "0 NxWx -> E 3 \n" +
            "0 xExx -> S 0 \n" +
            "2 NxWx -> E 4 \n" +
            "1 Nxxx -> S 2 \n" +
            "2 xxWS -> X 3 ";
    
    // constants related to the Picobot simulation
    public static final int ROWS = 20;
    public static final int COLS = 20;
    public static final int STATES = 5;
    
    // constants related to the genetic algorithm.
    public static final int TRIALS = 20;
    public static final int STEPS = 1000;
    public static final double MUTATIONRATE = 0.02;
    public static final double TOPFRACTION = 0.2;

    // fields needed by PicobotGA
    private ArrayList<Program> programs;
    private Picobot bestPicobot;
    private double avgFitness;
    private double bestFitness;
    private Program bestProgram;
    private TreeMap<Double, ArrayList<Program>> fitnessMap;
    private Random r;
    
    public PicobotGA(int popSize, int numGen) {
        // initializing the random generator used for choosing random rows
        // and columns for Picobots.
        r = new Random();
        
        // Printing out info for the user
        // TODO remove this when the gui works.
        System.out.println("Grid size is " + ROWS + " rows by " + COLS + " columns.");
        System.out.println("Fitness is measured using " + TRIALS + " random trials and " + STEPS + " steps for each trial");
        // creating a new population of programs.
        programs = newPop(popSize);
        // holds the current fitness for whatever program we're looking at.
        // (though we aren't looking at it quite yet)
        double fitness;
        // Looping the requested number of generations to measure fitness.
        for (int g = 0; g < numGen; g++) {
            fitnessMap = new TreeMap<>();
            // initializing the fitness map.
            // looping over every program in the generation to find its fitness,
            // so we can find the best program, fitness, etc.
            for (int p = 0; p < programs.size(); p++) {
                // Getting a program, finding its fitness, and adding the
                // program and its fitness to the map (the [key, value] pair is
                // [fitness, program]).
                Program program = programs.get(p);
                fitness = evaluateFitness(program, TRIALS, STEPS);
                ArrayList<Program> progList;
                if (fitnessMap.containsKey(fitness)) {
                    progList = fitnessMap.get(fitness);
                    progList.add(program);
                }
                else {
                    progList = new ArrayList<Program>();
                    progList.add(program);
                }
                fitnessMap.put(fitness, progList);
            }
            // once we've gone through every program, we find the last key in
            // our map, which (since it's a TreeMap) is also the highest key
            // (highest fitness).  We store this fitness along with the program
            // that led to it.  We then create a Picobot based on this program
            // at a random position, and store that as the best Picobot object
            // so that the solution can be visualized later if the user
            // requests.
            bestFitness = fitnessMap.lastKey();
            ArrayList<Program> bestArray = fitnessMap.get(bestFitness);
            bestProgram = bestArray.get(0);
            // calculating the total and then average fitness from the
            // fitness map.
            double total = 0;
            for (Map.Entry<Double, ArrayList<Program>> entry : fitnessMap.entrySet()) {
                total += entry.getKey();            
            }
            avgFitness = total / popSize;
            // Printing information about the generation 
            // TODO remove when gui works (or set as option).
            System.out.println("Generation " + g  + ":");
            System.out.println("Average fitness for this generation is: " + avgFitness);
            System.out.println("Best fitness for this generation is: " + bestFitness);
            // generating the next generation of programs, and mutating some
            // of those programs.  Mutation is handled by the
            // Program offspring method.
            programs = nextGen(popSize);
        }
        int ro = r.nextInt(ROWS) + 1;
        int co = r.nextInt(COLS) + 1;
        bestPicobot = new Picobot(ro, co, bestProgram);
        System.out.println("Best Program: ");
        System.out.println(bestProgram.toString());
    }
    
    // given a number of programs to create, creates an arraylist with that
    // many new programs.  All programs are randomized before being added.
    private ArrayList<Program> newPop(int popSize) {
        ArrayList<Program> progList = new ArrayList<>();
        Program prog;
        for (int p = 0; p < popSize; p++) {
            prog = new Program();
            prog.randomize();
            progList.add(prog);
        }
        return progList;
    }
    
    // returns the fitness of a given program, running TRIALS random trials 
    private double evaluateFitness(Program p, int trials, int steps) {
        // this keeps track of the squares visited by the Picobot holding the
        // program we are testing.
        int numVisited = 0; 
        // the random row and column we've chosen and the Picobot used for
        // testing the program.
        int randRow;
        int randCol;
        Picobot testBot;
        // looping for the given number of trials
        for (int t = 0; t < TRIALS; t++) {
            // selecting a random row and column and creating a Picobot that
            // starts at that position.
            // adding by one because we can't be in row 0 and we would like to
            // be able to be in row ROWS. (same for columns).
            randRow = r.nextInt(ROWS - 1) + 1;
            randCol = r.nextInt(COLS - 1) + 1;
            testBot = new Picobot(randRow, randCol, p);
            // running the Picobot for the given number of steps.
            // if we run into the exception below, we've encountered a very
            // bad Program and we give it the exceptionally low fitness of
            // zero.
            //try {
                testBot.run(steps);  
            /*} catch(ArrayIndexOutOfBoundsException | NullPointerException e) {
                numVisited = 0;
                break;
            }
            */
            
            // keeping track of how many squares have been visited.
            numVisited += testBot.numvisited; 
        }
        // We find the average number of squares visited over all trials, 
        // and then normalize that average by dividing by the total number
        // of squares. This gives us the fitness value for the program (as
        // squares visited is our metric for fitness.
        double avgNumVisited = numVisited / (double)trials;
        double fitness = avgNumVisited / (double)(ROWS * COLS);
        return fitness;
    }
    
    // creates the next generation of Picobot programs based on the results
    // from the previous one and some parameters.
    private ArrayList<Program> nextGen(int popSize) {
        // creating arraylists to store the next generation and the surviving
        // members of the previous one.
        ArrayList<Program> next = new ArrayList<>();
        ArrayList<Program> survivors = new ArrayList<>();
        // take only the TOPFRACTION proportion of the population as survivors.
        // round up to be nice.
        int numSurvivors = (int)Math.ceil(TOPFRACTION * popSize);
        // We want to add new survivors until we have the fraction we said
        // we would preserve.
        while (survivors.size() < numSurvivors) {
            /* 
             * The arraylist of best programs is arranged such that programs
             * with duplicate fitness will be attached to the same key.
             * So, we retrieve the arraylist of programs for the best key.
             */ 
            double maxFit = fitnessMap.lastKey();
            ArrayList<Program> best = fitnessMap.remove(maxFit);
            /* 
             * If we can add the whole arraylist without going over our number
             * of survivors, we do.
             */
            if (survivors.size() + best.size() < numSurvivors) {
                for (Program p : best) {
                    survivors.add(p);
                }   
            }
            /*
             * If we can't, we just add programs until we hit our limit.
             */
            else {
                int p = 0;
                while (survivors.size() < numSurvivors) {
                    Program curProgram = best.get(p);
                    survivors.add(curProgram);
                    p++;
                }
            }   
        }      
        while (next.size() < popSize) {
            int p1 = r.nextInt(survivors.size());
            int p2 = r.nextInt(survivors.size());
            if (p1 != p2) {
                Program parent1 = survivors.get(p1);
                Program parent2 = survivors.get(p2);
                Program offspring = parent1.crossover(parent2, MUTATIONRATE);
                next.add(offspring);
            }
        }
        return next;
    }
    // through the maze with STEPS steps each.
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        //PicobotGA ga = new PicobotGA(2000, 50);
        System.out.println(BESTFITNESS);
    }
}
